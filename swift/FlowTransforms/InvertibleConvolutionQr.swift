import Foundation
import TensorFlow

public struct InvertibleConvolutionLayerQr: Layer {
    public var r: Tensor<Float>
    
    // Q is fixed after initialization, so it's determinant remains 1
    @noDerivative
    public var q: Tensor<Float>
    
    init(dim: Int) {
        // generate a random rotation matrix by creating a matrix with standard normals
        // then, taking the Q part of the QR decompisition

        let w = random_rotation(dim: dim)
        let qr = w.qrDecomposition()
        
        self.q = qr.q
        self.r = qr.r
    }
    
    @differentiable
    public func callAsFunction(_ input: TensorDeterminant) -> TensorDeterminant {
        let x = input.val.expandingShape(at: [2]);
        let val = matmul(q, matmul(r_value(), x)).squeezingShape(at: [2])
        
        return TensorDeterminant(from: input, to_val: val, log_det: log_determinant())
    }
    
    public func reverse(_ output: TensorDeterminant) -> TensorDeterminant {
        // invert the matrix using the QR-decomposition
        // We have the system Ax = b, generated by callAsFunction
        // We have the value output, which is b in row vector form
        // 'Ax = b' is equalvalent to 'R x = transpose(Q) b'
        // (from https://math.stackexchange.com/questions/109329/can-qr-decomposition-be-used-for-matrix-inversion)
        // So, we first reduce 'transpose(Q) b' to a column vector qt_b, and then solve 'R x = qt_b'
        
        let r_tiled = r_value().rankLifted().tiled(multiples: [output.val.shape.dimensions[0], 1, 1]);
        
        let b = output.val.expandingShape(at: [2])
    
        let qt_b = matmul(q.transposed(), b)
        let x = triangularSolve(matrix: r_tiled, rhs: qt_b, lower: false)
    
        let val = x.squeezingShape(at: [2])
        
        return TensorDeterminant(from: output, to_val: val, log_det: 1.0 / log_determinant())
    }
    
    func log_determinant() -> Tensor<Float> {
        // We need to consider both the multiplication by Q and R
        // Q is an orthogonal matrix, which have determinants of either -1 or 1
        // qrDecomposition() seems to always create one with 1, so we just need to compute the determinant of R
        // R is an upper triangular matrix, which is the product of the diagonal entries
        return log(abs(r.diagonalPart())).sum()
    }
    
    // Only use the upper triangular part
    func r_value() -> Tensor<Float> {
        return r.bandPart(subdiagonalCount: 0, superdiagonalCount: 1)
    }
}
